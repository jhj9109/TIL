# 0427 장고

- messages.success(request,'메세지')
  - 검색해보기 : django massage framwork

class storage.{ }.{ }Storage

- session
  - c9 환경
- cookie
- fallback

```python
from django.contrib import massages

messages.warning(request, '멘트')
```

- 세션쿠키 활용하기때문에 request 인자

```python
# base.html
{% if messages %}
<ul class="messages">
    {% for message in messages %}
    <li{% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}</li>
    # 부트스트랩 적용 class = "alert alert-{{ message.tags }}"
    {% endfor %}
</ul>
{% endif %}
```

## 4xx (요청 오류)

- 401(권한 없음) : 비 로그인시
- 403(Forbidden, 금지됨) : 로그인 but 권한 밖

## HTTPResponse Object 

```python
from django.http import HttpResponseForbidden
return HttpResponseForbidden()
# 403 status code 반환
```



```python
@require_POST
@login_required
# 비로그인 x > 댓글 작성 > login_required > next로직 (GET) > 405 Error
```

```python
from djang.http import HttpResponse
@require_POST
def xxx(request, pk):
    if request.user.is_authenticated:
        pass
    else:
        # 방법1. next parameter 없이 진행
        return redirect('accounts:login')
    	# 방법2. 
        return HttpResponse(status=401)
```

## 템플릿 쪼개기

`_nav.html`

{% include '_nav.html' %}

- 확장 extends
- 포함 include



오늘 배울꺼

- 이미지필드
- 1:N 쿼리
- M:N 개념

## Image Field

> 공식문서 : Managin files
>
> Requires : Pillow library > pip 설치

이미지 업로드

- pip install pillow

기존 모델 수정

- add non-nullable field '필드명'  to 클래스명 without a default
  1.  지금 default 설정 > 파이썬 콘솔환경
  2.  종료후 models.py에 default 설정

- `ImageField(blank=True)`

검색 > html form file 

create.html

- `enctype="multipart/form-data"` : 파일 받고자 한다면

views.py

- 넘겨주는  form에 request.FILES

- 장고폴더에 이미지가 추가되어있는것을 볼수 있다.

아직 이미지가 깨진다 > MEDIA_URL MEDIA_ROOT설정

- `{{ 모델명.image.url }}`

파일명중복시 랜덤한 string붙여서 저장해준다.

**현재 이미지 원본 받는중**

리사이징

- django-imagekit

models.py

- 변수_thumbnail
  - source : 어떤 이미지
  - process : process : 어떤 방식으로
  - format : 형식

```python
from imagekit.models import ImageSpecField
# 원본 저장 + 활용
from imagekit.models import ProcessdImageFiel
# 원본을 잘라서 저장
from imagekit.processors import ResizeToFill, ResizeToFit, image_thumbnail
#ResizeToFill : 300*300 자르는 것 (crop)
#ResizeToFit : 가장 긴 곳을 300으로 맞추고 비율에 맞춤
#thumbnail : smart resizing
```



# OneToMany

```python
# 1번 유저 작성한 글
u1.article_set.all()
# 2번 유저 작성한 댓글
u2.comment_set.all()
# 3번 글의 댓글
a3.comment_set.all
# 제목1 인 게시글
Article.objects.filter(title='제목1')
# 제목에 `단어1`가 들어간 게시글
Article.objects.filter(title__contains='단어1')
# 댓글들(N) 중에 글(1)의 제목이 제목1인 것
Comment.objects.filter(article__title='제목1')

```



## M:N

>  좋아요기능, 예약테이블
>
> 새로운 테이블이 필요하다

```python
class Reservation(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE)
```

- article_id (FK) , Doctor_id
- user_id (FK), Patient_id

```python
for res in d1.reservation_set.all():
    print(res.patient.name)
```

```python
# M:N 필드! reservation 통해서, 닥터
doctors = models.ManyToManyField(Doctor, through='Reservation')

p1.doctors.all()
# d1.patients.all() 에러
d1.patient_set.all()

# 역참조 옵션 : 기본 {모델_set}, related_name {설정값}
doctors = models.ManyToManyField(Doctor, through='Reservation', related_name='patients')
d1.patients.all()
```

- ManyToManyField 작업은 DB 영향X

  

 



# 0428

> M:N, models.ManyToMany

```python
from django import model
class Reservation(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE)
```



```python
# Article 클래스에 정의된 user 
article.user = request.user
# 실제 DB에는 변수명_id로 저장된다.
article.user_id = 1

Article.objects.create(user=request.user)
Article.objects.create(user_id=1)

d3.reservation_set.all()
Reservation.objects.filter(doctor_id=3)

Reservation.objects.get(doctor_id=3, patient_id=1).delete()
Reservation.objects.filter(doctor_id=3, patient_id=1)[0].delete()
```



```python
class Patient(models.Model):
    # ORM에서 제공하는 기능
    doctors = models.ManyToManyField(
    		Doctor,
    		through='Reservation',
        	related_name='patients'
    )
p1.doctors.all()
d1.patient_set.all()
# 역참조 설정하였다면
d1.patiendts.all()
```

```python
# through 삭제, Reservation 삭제후
# manytomany_patient_doctors 테이블이 생성됨

d1.patients.add(p1)
#p1.doctors.add(d1)도 가능하겠지

# Reservation 테이블이 필요할땐? 관계외 추가 테이블이 필요할때
```

```python
# 역참조 기능이 무조건 필요할까?
# 좋아요 기능을 구현해보자!
# 아티클, 좋아요 테이블 모두 user_id를 가지고 있다!
# User.article_set은 누굴 의미.....???

# article.user 작성자
# article.users 좋아요 누른 사람 > like_users (역참조명'like_articles')
# user.article_set 작성글들


```

```python
# url : article/pk/like
# view : 이미 눌렀는지 분기

# 1. urls.py path 추가
# 2. views.py like 추가
def like(request, pk):
    article = get_object_or_404(Article, pk=pk)
    #좋아요 누른적 있다
    #if request.user in article.like_users.all():
    if article.like_users.filter(id=request.user.pk).exists(): #user quertset
        article.like_users.remove(request.user)
    else:
        article.like_users.add(request.user)
    #없다
    return redirect('articles:detail', pk)
# 템플릿
{% if request.user in article.like_users.all %}
<p>좋아요 취소</p>
{% else %}
<p> 좋아요 </p>
{% endif %}
```

꾸미기 site

- font awesome
- animate css

### DB

### 1:N

- 정의 : 모델 단수형(.user)
- 역참조 : 모델_set (.article_set)

### M:N

- 정의 및 역참조 : 모델 복수형 (like_users, like_articles)



### With: 중복된 코드 묶기

```python
{% with article_like_users = article.like_users.all %}
	일종의 캐싱
    {% article_like_users | count %}
{% endwith %}
```

### USER 꺼내오기

- accounts/models.py

```python
from django.contrib.auth.models import AbstractUser
from django.conf import settings
class User(AbstractUser):
    followers = models.ManyToManyField(
    		settings.AUTH_USER_MODEL,
    		related_name="followings"
    )
```

- settings.py

````python
# AUTH_USER_MODEL = 'auth.User' : 기본값
AUTH_USER_MODEL = 'accounts.User'
````

- admin.py

```python
from .models import User
admin.site.register(User)
```

- forms.py

```python
from django.contrib.auth import get_user_model()
from django.contrib.auth.forms import UserChangeForm, UserCreationForm

class CustomUserChangForm(UserChangeForm):
    class Meta:
		model = get_user_model()
        fields = ['username', 'first_name', 'last_name', 'email']
class CustomCreationForm(UserCreationForm):
    class Meta:
        model = get_user_model()
        fields = ['email', 'username']
        
# AuthenticationForm 은 ModelForm이 아니므로 위 작업이 불필요하다.
```

### Follow

- url : accounts / variable routing / follow /
- view : 팔로우 여부 분기 > remove or add
- Template : redirect > user detail 

- urls.py

- views.py

```python
def follow(request, pk):
    User = get_user_model()
    # 팔로우 당할 위기의 사람
    user = get_object_or_404(User, pk=pk)
    # 팔로우 하려는 사람
    if user.followers.filter(pk=request.user.pk).exist():
        user.followers.remove(request.user)
    else:
        user.followers.add(request.user)
    return redirect('accounts:detail', user.pk)
# 좋아요 기능과 거의 동일하다 > article:user에서 user:user 관계만 변함
```

- detail.html

```python
{% with user_folloewrs=user.followers.all%}
{% if request.user in user_folloewrs %}
	<a href="{% url 'accounts:follow' user.pk %}">팔로우</a>
{% else %}
	<a href="{% url 'accounts:follow' user.pk %}">팔로우</a>	
{% endif %}
	<p>{{ user_folloewrs|length }}명이 팔로우하고 있습니다.</p>
    <p>내가 {{ user_folloewings.count }}명을 팔로우하고 있습니다.</p>

```

- 추가 기능 : 유저상태 따른 분기
- 기본 DB 컨벤션 > 이름 동일 > **from/to_model_id**

프로필 페이지

```python
# 사용자의 글
{% for article in user.article_set.all %}
	<a href="{% url 'articles:detail' article.pk %}">
		<p>{{ article.title }}</p>    	
    </a>
{% endfor %}
# 사용자가 좋아요한 글
{% for article in user.like_articles.all %}
	<a href="{% url 'articles:detail' article.pk %}">
		<p>{{ article.title }}</p>    	
    </a>
{% endfor %}
```

앞으로 초기 세팅

```python
from django.contrib.auth.models import AbstractUser
class User(AbstractUser):
    pass
```

어드민 페이지가기

`{% url 'accounts:detail' article.user.pk %}`





## 만들기

> either.io

## 미래에

- JS (vanilla) : 좋아요등 할때 http가 불편...할때 go
- Vue.js (JS Framework)
- Django Rest Framework (API Server)
  - CBV(Class Based View)
  - RESTful API
- MSA(Micro Service Architecture)

배포

- Paas (Heroku)
  - 다양한것을 제공
- laas (AWS)

## 최종

- Django Monolithic
- Django Server & Vue.js Frontend

