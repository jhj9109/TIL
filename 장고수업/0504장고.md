# Gravatar 아바타 제공

- API

  - HTTP GET

- ```python
  # 1.Trim 앞뒤를 제거해라
  # 2.lower-case
  # 3. md5 hash > 복호화 가능
  email = '이메일@주소'
  email.strip().lower()
  
  import hashlib
  hashlib.md5(email.encode('utf-8')).hexdigest() # 인코드 필요
  hashlib.md5(email.encode('utf-8').strip().lower()).hexdigest()
  ```

- ```python
  <img src="https://s.gravatar.com/avatar/{{ request.user.email_hash }}?s=80">
  ```

- ```python
  # views.py
  import hashlib
  email_hash = hashlib.md5(email.encode('utf-8').strip().lower()).hexdigest()
  ```

## Templatetags

> `__init__.py`
>
> `poll_extras.py` >>> `gravatar.py`
>
> {% load %}  기존에 {% load bootstrap4 %}

`django custom template tag` 검색

```python
# 예시 코드
from django import template
from django.template.defaultfilters import stringfilter

register = template.Library()

@register.filter
@stringfilter
def lower(value):
    return value.lower()
```

```python
from django import template
from django.template.defaultfilters import stringfilter # 없어도 무방
import hashlib

register = template.Library()

@register.filter
@stringfilter # 없어도 무방
def profile_url(email):
    return f"https://s.gravatar.com/avatar/hashlib.md5(email.encode('utf-8').strip().lower()).hexdigest()?s=80"
```

```python
# template.html
{% load gravatar %}
<img src="{{ request.user.email|prfile_url }}">
```

## 디폴트 이미지

그라바타 사이트에 예시 http url을 사용한다.

## Model > @property (파이썬 문법)

> 실제 DB에 저장하는 속성값 > 필요한 속성 값 추출 

```python
def gravatar_url(self):
    return f"https://s.gravatar.com/avatar/hashlib.md5(email.encode('utf-8').strip().lower()).hexdigest()?s=80"

# request.user.gravatar_url 사용 가능
```

정리

1. Temlpate tag & filter : 템플릿 T 안에서 사용하는 파이썬파일
   - 커스텀하여 추가적인 필터와 태그 사용가능
2. Model 연관이 있다면 > @property : 모델 M
   - views.py에서도 활용 가능
   - abstractuser
     - def is_authenticated(self): return true
     - 메소드가 아닌 속성값으로 정해져 있었다.

여러가지

- ERD
  - draw.io
  - crdcloud
- sketch
  - 디자이너와 협업
- tree .
  - 리눅스(우분트 기본탑재)
- github 기술면접

편의점 관리 프로그램

- 지점
- 상품
  - 카테고리 : 관계



장고 쿼리셋

1. lazy
2. evaluated
   1. 반복
   2. 슬라이싱 (스탭)
   3. 프린트
   4. len
   5. bool
3. data held in memory
   1. {% with %} 구문처럼 생각하면 된다.



1. 게시글별 댓글수출력

   1. - `{{ article.comment_set.count }}`
      - 11번의 sql 발생

   2. - ```python
        article = Article.objects.annotate(comment_set_count = Count('comment')).order_by('pk')
        ```

      - 1번의 sql 발생

2. 게시글 작성자 출력

   1. - {{  article = Atricle.user.username }}
      - 11번의 sql 발생 : N + 1 문제

   2. - 

        ```python
        Article.objects.select_related('user').order_by('-pk')
        ```

      - 1번의 sql 발생

      - INNER JOIN : 두개의 테이블을 하나로

3. 게시글마다 댓글 출력

   1. ```python
      {% for comment in article.commnet_ser.all %}
      	<p> comment.content </p>
      {% endfor %}
      ```

   2. ```python
      Article.objects.prefetch_related('comment_set').order_by('-pk')
      ```

   3. 2 번의 sql 발생

      1. a1, a2 ....
      2. comment_set 붙인다 (파이썬)

select_related : `SQL join`

prefetch_related : `joining in Python`

4. 게시글의 댓글마다 이름과 댓글 출력

   1. - 게시글1

      - 게시글의 댓글 x10
      - 게시글의 댓글의 유저 x10
      - 총 111 쿼리

   2. ```python
      Article.objects.select_related('comment_set').order_by('-pk')
      ```

   3. ```python
      from django.db.models import Prefetch
      articles = Article.objects.prefetch_related(
          Prefetch(
              'comment_set',
              queryset=Comment.objects.select_related('user')
      	).order_by('-pk')
      ```

      - 총 2쿼리

   정리

   1:1, 1:N (N이 1을 찾을때, foreignkey가 정의된 곳)에서 찾을 수 있다.

```sql
-- 게시글(A) + 댓글(B)
SELECT * FROM article
LEFT OUTER JOIN comment
ON article.id = comment.article_id;
-- 게시글(A) + 사용자
SELECT * FROM article
INNER JOIN user
ON article.user_id = user.id;
```



옵티마이제이션

- .count() / .exists() 활용하라. DB에서 계산
  - 고려할 사안 : with 구문을 통해 QuerySet 캐싱 => len 쓰는게 좋다
- 단순 중복 : N + 1 Problem
  - `annotate` : 단순 계산 결과 필드
  - `select_related` :  1:1 or N >> 1
  - `prefetch-related` : M:N, 1 >> N





막간정리

- 물리폴더 X > 모듈 관리  : 템플릿, 정적파일, 이미지