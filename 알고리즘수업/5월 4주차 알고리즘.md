# 	Graph

## 1. 학습내용

- 실세계의 문제를 그래프로 추상화하여 해결하는 것이 목적
- 그래프 탐색 기법 : BFS, DFS
- DisJoint-Sets (상호배타 집합) 자료구조
- Minimum Spanning Tree (최소 신장 트리)
- 그래프에서 탐욕 기법을 활용하여 MST 찾는 알고리즘
- 두 정점 사이의 Shortest Path (최단 경로) 찾는 방법

## 2. 그래프 특징

- Vertex (정점) | Edge (간선)

- Vn, En : 정점과 간선의 갯수
- 최대 간선 수 :  (Vn * ( Vn-1) / 2) 개

- 선형 및 트리 자료구조로 표현하기 힘든 N:N 관계 표현 용이

## 3. 그래프 유형

- Undeirected Graph (무향 그래프)
- Directed Graph (유향 그래프)
- Weighted Graph (가중치 그래프)
- DAG, Directed Acyclic Graph (사이클 없는 방향 그래프)

## 4. 그래프 용어

- 완전그래프 : 최대 간선 갯수를 가진 그래프 ( <-> 부분그래프)

- 인접(adjacency) : 두 정점 사이에 간선이 존재

- 경로 : 간선들을 순서대로 나열
  - 단순경로 : 경로 중 한 정점을 최대 한 번만 지나는 경로
  - Cycle : 시작한 정점에서 끝나는 경로

## 5. 간선의 정보를 저장하는 방식

- Adjacent matrix : V x V 크기의 2차원 배열 이용해 간선 정보를 저장, 배열의 배열 (포인터 배열)
- Adjacent List : 각 정점마다 해당 정점으로 나가는 간선의 정보 저장
- 간선의 배열 : 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

### 5.1. Adjacent matrix

#### 5.1.1 특징

- V x V 정방 행렬
- 행, 열 번호는 그래프의 정점에 대응
- 두 정접이 인접하면 1, 아니면 0
- 무향 그래프 : ∑i행 = ∑i열 = Vi 차수
- 유향 그래프 : ∑i행 = Vi 진출 차수, ∑i열 = Vi 진입 차수

#### 5.1.2 단점

- 간선이 적은 그래프(희소그래프)도 V*V 크기의 공간 확보
- 인접정점 찾을때 인접 정점이 적더라도 V번의 연산 필요

### 5.2. Adjacent List

#### 5.2.1 특징

- 각 정점에 대한 인접 정점들을 순차적으로 표현
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장
- 무향 그래프
  - 노드 수 = 간선수 * 2
  - 각 정점의 노드 수 = 각 정점의 차수

- 유향 그래프
  - 노드 수 = 간선수
  - 각 정점의 노드 수 = 각 정점의 진출 차수

#### 5.2.2 단점

- 유향 그래프의 진입 차수 찾기 위해선 모든 정점 탐색 (진출차수)

## 6. 그래프 탐색

- 그래프 순회 : 비선형구조인 그래프로 표현된 모든 정점을 빠짐없이 탐색하는 것
- Depth First Search
  - 무향그래프 & 1명의 친구에게 전달 & 중복 X &  최대 전달 갯수
- Breadth First Search
  - 무향그래프 & 모든 친구에게 전달 & 가능 늦게 받는 친구

### 6.1. DFS

- 시작 정점의 한 방향으로 깊이 탐색, 마지막 갈림길 정점(간선有)으로 돌아와 다른 방향 깊이 탐색
- 후입선출 구조의 ```스택``` 사용

```python
def DFS_rec(G, v):
    visited[v] = True
    for w in G[v]:
        if not visited[w]:
    # for i in range (1, len(G)):
        # if G[v][i] and not visited[i]:
            DFS(G, w)
```
```python
def DFS_iter(v):
	s = [v]
	visited[v] = True
	while s:
        now = s.pop()
        # 수행
        for w in G[now]:
            if not visited[w]:
        # for i in range (1, len(G)):
            # if G[now][i] and not visited[i]:
                s.append(w)
                visited[w]
```

### 6.2. BFS

- 시작점의 인접정점부터 모두 차례로 방문하고, 방문했던 정점을 시작점으로 하여 반복
- 선입선출형태의 자료구조인 큐를 활용

#### 6.2.1 Queue

- 스택처럼 삽입(enQueue) & 삭제(deQueue)의 위치가 제한적인 구조
- 선입선출형태 (FIFO, First In First Out)
- 용어
  - Front
  - Rear

- 공백 큐 생성 : `front = rear = -1`
- 원소 삽입 : `rear += 1; q[rear]=삽입원소`
- 원소 반환 : `front += 1; 반환원소=q[front]`

```python
def EnQueue(Q, X):
    if Q.isFull(): # rear == len(Q)-1
        pass
    else:
        rear += 1
        Q[rear] = X
def DeQueue(Q):
    if Q.isEmpty(): # front == rear
        pass
    else:
        front += 1
        return Q[front]
```

```python
def bfs(G, v):
    q = deque([v])
    visited[v] = 1
    while q:
        v = q.popleft()
        # 정점에서 수행할 행동
        for w in G[v]:
            if not visited[w]:
                q.append(w)
                visited[w] = 1
```

## 7. 상호배타 집합 (Disjoint - sets)

> 서로소 집합 or 상호배타 집합, 서로간에 교집합이 공집합인 집합
>
> 대표자 (representative)

- 표현
  - 연결 리스트
  - 트리
- 연산
  - Make-Set( x ) : 원소 x를 유일한 원소로하는 집합 생성
  - Find-Set( x ) : x가 포함된 집합의 대표자 리턴
  - Union( x, y) : x, y가 각각 포함된 집합을 합집합

### 7.1. 상호배타 집합의 표현 - 연결리스트

- 특징
  - 같은 집합의 원소들을 하나의 연결리스트로 관리
  - 맨 앞의 원소를 집합의 대표 원소로 삼는다
  - 각 원소는 ```집합의 대표원소를 가리키는 링크```를 갖는다

### 7.2 상호배타 집합의 표현 - 트리

#### 7.2.1 특징

- 상호배타 집합은 연결리스트보다 트리를 주로 활용
- 하나의 상호배타 집합을 하나의 트리로 표현
- 자식 노드가 부모 노드를 가리키며 루트노드가 대표자가 된다
- 트리의 배열을 이용

```python
# p: 부모, x: 정점
def make_set(x):
    p[x] = x
def find_set(x):
    if x == p[x]:
        return x
    else:
        find_set(p[x])
def union(x):
    p[find_set(y)] = p[find_set(x)]
```

#### 7.2.2 문제점

- 대표자를 찾기 위해 재귀표현이 길어질 가능성 존재
- 대표자를 바로 찾을 수 있도록 : ```path compression```

#### 7.2.3 연산의 효율을 높이는 방법

##### 7.2.3.1 Rank를 이용한 Union

- 각 노드는 자신을 root로 하는 subtree의 높이를 Rank라는 이름으로 저장한다
- 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙인다

##### 7.2.3.2Path compression

- Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어 준다

```python
def make_set(x):
    p[x] = x
    rank[x] = 0
def find_set(x):
    if x != p[x]:
        p[x] = find_set(p[x])
    return p[x]
def union(x):
    Link (find_set(x), find_set(y))
def Link (px, py): #각 집합의 부모 px, py
    If rank[px] > rank[py]:
        p[py] = px
    else:
        p[px] = py
        if rank[px] == rank[py]:
            rank[y] += 1
```

## 8. MST (Minimum Spanning Tree)

> 

그래프 최소비용 문제

- 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - MST : 프림, 크루스칼
- 두 정점 사이의 최소 비용의 경로 찾기
  - 최단 거리 : 무가중치 : BFS, 가중치 : 다익스트라

신장 트리 & 최소 신장 트리

- ```무방향그래프, n 개의 정점, n-1개의 간선```으로 이루어진 트리

- 무방향 가중치 그래프, 가중치의 합이 최소인 신장 트리

### 8.1 MST 표현

가중치 표현

- Adjacent matrix : 가중치값을 필드값으로
- Adjacent List : [node, 가중치값]

### 8.2 Prim 알고리즘

하나의 ```**정점**```에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식

- 임의의 정점을 하나 선택하여 시작
- 선택된 정점들과 인접정점들 중의 최소 비용의 간선 선택
- 모든 정점이 선택될 때 까지 반복

2 Disjoint-sets 정보 유지

- Tree vertices : MST를 만들기 위해 선택된 정점들
- Nontree vertices : 선택되지 않은 정점들

방법1

- 빈 배열 준비 (key, π)
- 초기화 : key:무한대, π : None or -1
-  key[시작점] = 0
- 아직 MST가 아니면서 key가 최소인 정점 **u** 선택 MST에 포함
- u에 인접하며 아직 MST X인 정점 **w**
- if key[w] > u-w 가중치 : 갱신

```python
V, E = map(int, input().split())

# 인접행렬
adj = [[o] * V for _ in range(V)]
for i in range(E):
    s, e, c = map(int, input().split())
    adj[s][e], adj[e][s] = c, c

    # 초기화: key, p, mst
INF = float('inf')
key = [INF] * V
p = [-1] * V
mst = [False] * V

# 시작점 선택: 0번 선택
key[0] = 0

# 스타트
cnt = 0
result = 0
while cnt < V :
    # Nontree & key가 최소인 정점 선택: u, minV
    minV = INF
    u = -1
    for i in range(V):
        if not mst[i] and key[i] < minV:
            u = i
            minV = key[i]
            
    # u를 mst로 선택
    mst[u] = True
    result += minV
    
    # key값을 갱신 with p
    # u에 인접하고 and Nontree and 현재key값보다 작은 가중치면
    for w in range(V):
        if not adj[w][u] and not mst[w] and adj[w][u] < key[w]:
            key[w] = adj[w][u]
            p[w] = u
    cnt += 1
print(key)
print(p)
print(result)
```

```
# 수도코드
MST_PRIM(G, r) // G: 그래프, r: 시작 정점
	// 초기화
	FOR u in G.V
		u.key = 무한대 // u.key: u에 연결된 간선중 최소 가중치
		u.파이 = Null // u.파이: 트리에서 u의 부모
	// 시작점
    r.key = 0
    
    
    Q = G.V // 우선순위 Q에 모든 정점 넣는다 -> For 시간복잡도(빨리 꺼낼수 있다) -> 이진힙으로 구현
    WHILE Q != 0
    	u = Extract_MIN(Q) // key 값이 가장 작은 정점 가져오기
    	FOR v in G.Ajd[u] // u의 인접 정점들
    		IF v == Nontree AND w(u, v) < v.key // Q에 있는 v의 key값 갱신
    			v.파이 = u
    			v.key = w(u, v) // Q도 갱신한다.
    			
    			
```

#### 8.3.1  우선순위 큐를 사용한 Prim

```python
import heapq

V, E = map(int, input().split())
adj = {i :[] for i in range(V) }
for i in range(E):
    s, e, c = map(int, input().split())
    adj[s].append([e, c])
    adj[e].append([s, c])
#print(adj)

# key, mst, 우선순위Q
INF = float('inf')
key = [INF] * V
mst = [False] * V
pq = []

# 시작 정점 선택: 0
key[0] = 0
# 큐에 시작 정점을 넣음 => (key, 정점인덱스)
# 우선순위 큐 -> 이진힙 -> heapq 라이브러리 사용
heapq.heappush(pq, (0, 0)) # 우선순위큐 -> 원소의 첫번쨰요소 -> key를 우선순위로

result = 0
while pq:
    #최소값 찾기
    k, node = heapq.heappop(pq) # node == u
    if mst[node]:
        continue
    #mst로 선택
    mst[node] = True
    result += k
    
    #key 갱신 => key배열 / 큐
    for dest, wt in adj[node]: #노드, 가중치
        if not mst[dest] and  wt < key[dest]:
            key[dest] = wt
            heapq.heappush(pq, (key[dest], dest))
            #큐 갱신
            #방법1: (key, 정점)수정
            #방법2: 새로운 (key, 정점) 삽입 => 필요없는 원소 스킵
print(result)
```



### 8.3 Kruskal 알고리즘

간선을 하나씩 선택해서 MST를 찾는 알고리즘

- 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
- 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
  - **사이클**을 만드는 간선은 건너 뜀
- n-1개의 간선이 선택될 때 까지 반복

#### 8.3.1 수도코드

```
MST-KRUSKAL(G, w)
	A = 0 				// 공집합
	FOR vertex v in G.V: // G.V: 그래프의 정점 집합
		Make_Set(v)		// G.E: 그래프의 간선 집합
    
    G.E에 포함된 간선들을 가중치 w에 의해 정렬	// 자료 크기가 클때, 높은 복잡도
    
    FOR 가중치가 가장 낮은 간선 (u, v) ∈ G.E 선택		   //(V-1개)
    	IF Find_Set(u) != Find_Set(v):					//사이클 여부
    		A = A ∪ {(u, v)}
    		Union(u, v)
    RETURN A
```



#### 8.3.2 코드1

```python
def make_set(x):
    p[x] = x

def  find_set(x):
    if p[x] == x:
        return x
    else:
        p[x] = find_set(p[x])
        return p[x]
def union(x, y):
    px = find_set(x)
    py = find_set(y)
    if rank[px] > rank[py]:
        p[py] = px
    else:
        p[px] = py
        if rank[px] == rank[py]:
            rank[py] += 1
            
V, E = map(int, input().split())
edges = [list(map(int, input().split())) for i in range(E)]

# 간선을 간선가중치를 기준으로 정렬
edges.sort(key=lambda x:x[2])

# make_set : 모든 정점에 대해 집합 생성
p = [0] * V
rank = [0] * V
for i in range(V):
    make_set(i)

cnt = 0
result = 0
mst = []
# 모든 간선에 대해서 반복 -> V-1개의 간선이 선택될때까지
for i in range(E):
	# 단 사이클을 형성하면 스킵 == 간선의 두 정점이 서로 같은집합이면 (Find_Set)
	s, e, c = edges[i][0], edges[i][1], edges[i][2]
    if find_set(s) == find_set(e):
        continue
    result += c
    mst.append(edges[i])
    union(s, e)
    cnt += 1
    if cnt == V-1:
        break
# 간선 선택
# => mst에 간선 정보 더하기 / 두 정점을 합친다 => Union
```

## 9. 최단 경로

>  간선의 가중치가 있는 그래프에서 두 정점 사이에서 가중치의 합이 최소인 경로

- 가중치가 없는 그래프 > BFS로 해결해왔음

- 하나의 시작 정점에서 끝 정점까지의 최단경로
  - one to all (one to one에서 확장)
  - 다익스트라(dijkstra) 알고리즘
    - 음의 가중치를 허용하지 않음
  - 벨만-포드(Bellman-Ford) 알고리즘
    - 음의 가중치를 허용
  - 둘다 음의 가중치 사이클 X
- 모든 정점들에 대한 최단 경로
  - all pair (all to all)
  - 플로이드-워샬(Floyd-Warshall) 알고리즘

### 9.1 Dijkstra 알고리즘

> MST Prim 알고리즘과 유사

시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식

- 시작정점 s 에서 끝 정점 t 까지의 최단 경로에 정점 x가 존재
- 이때, 최단경로는 s에서 x까지의 최단경로와 x에서 t까지의 최단경로로 구성
- 탐욕 기법을 사용한 알고리즘으로 MST의 프림 알고리즘과 유사

- d[정점] : 시작점부터 정점까지의 거리 (현재까지 알아낸 최단거리)
  - id d[v] > d[u] + cost(u, v): d[v] = d[u] + cost(u, v); // 간선완화
  - d[정점]중 가장 작은 값을 지닌 정점을 선택해, 그 정점을 가지고 간선완화를 반복한다.
  - 루트는 다양 > 경로가 아닌 값에 대해 묻는다

#### 9.1.1 수도코드

```
s: 시작 정점, A: 인접행렬, D: 거리
V: 정점 집합, U: 선택된 정점 집합
Dijkstra(s, A, D)
	U = {s};
	
	For 모든 정점 v
		D[v] = A[s][v]
	
	WHILE U != V
		D[w]가 최소인 정점 w ∈ V-U를 선택
		U = U ∪ {w}
		
		FOR w에 인접한 모든 정점 v
			D[v] = min(D[v], D[w] + A[w][v])
```

```python
#dist, selected 배열 준비
#시작점 선택
#모든 정점이 선택될때까지
#아직 선택되지 않고 dist의 값이 최소인 정점 : u
#정점 u의 최단거리 결정
#정점 u에 인접한 점정에 대해서 간선완화

V, E = map(int, input().split())
adj = {i: [] for i in range(V)}
for i in range(E):
    s, e, c = map(int, input().split())
    adj[s].append([e,c]) #문제가 단방향 | 양방향에 대해서도 적용 가능
INF = float('inf')
dist = [INF] * V
selected = [False] * V

dist[0] = 0
cnt = 0
while cnt < V:
    #dist가 최소인 정점 찾기
    minV = INF
    u = -1
    for i in range(V):
        if not selected[i] and dist[i] < minV:
            minV = dist[i]
            u = i
    # 결정
    selected[u] = True
    cnt += 1
    
    # 간선완화
    for w, cost in adj[u]:
        dist[w] = min(dist[w], dist[u] + cost)
    
print(dist) 
```

