# Graph

## 1. 학습내용

- 실세계의 문제를 그래프로 추상화하여 해결하는 것이 목적
- 그래프 탐색 기법 : BFS, DFS
- DisJoint-Sets (상호배타 집합) 자료구조
- Minimum Spanning Tree (최소 신장 트리)
- 그래프에서 탐욕 기법을 활용하여 MST 찾는 알고리즘
- 두 정점 사이의 Shortest Path (최단 경로) 찾는 방법

## 2. 그래프 특징

- Vertex (정점) | Edge (간선)

- Vn, En : 정점과 간선의 갯수
- 최대 간선 수 :  (Vn * ( Vn-1) / 2) 개

- 선형 및 트리 자료구조로 표현하기 힘든 N:N 관계 표현 용이

## 3. 그래프 유형

- Undeirected Graph (무향 그래프)
- Directed Graph (유향 그래프)
- Weighted Graph (가중치 그래프)
- DAG, Directed Acyclic Graph (사이클 없는 방향 그래프)

## 4. 그래프 용어

- 완전그래프 : 최대 간선 갯수를 가진 그래프 ( <-> 부분그래프)

- 인접(adjacency) : 두 정점 사이에 간선이 존재

- 경로 : 간선들을 순서대로 나열
  - 단순경로 : 경로 중 한 정점을 최대 한 번만 지나는 경로
  - Cycle : 시작한 정점에서 끝나는 경로

## 5. 간선의 정보를 저장하는 방식

- Adjacent matrix : V x V 크기의 2차원 배열 이용해 간선 정보를 저장, 배열의 배열 (포인터 배열)
- Adjacent List : 각 정점마다 해당 정점으로 나가는 간선의 정보 저장
- 간선의 배열 : 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

### 5.1. Adjacent matrix

#### 5.1.1 특징

- V x V 정방 행렬
- 행, 열 번호는 그래프의 정점에 대응
- 두 정접이 인접하면 1, 아니면 0
- 무향 그래프 : ∑i행 = ∑i열 = Vi 차수
- 유향 그래프 : ∑i행 = Vi 진출 차수, ∑i열 = Vi 진입 차수

#### 5.1.2 단점

- 간선이 적은 그래프(희소그래프)도 V*V 크기의 공간 확보
- 인접정점 찾을때 인접 정점이 적더라도 V번의 연산 필요

### 5.2. Adjacent List

#### 5.2.1 특징

- 각 정점에 대한 인접 정점들을 순차적으로 표현
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장
- 무향 그래프
  - 노드 수 = 간선수 * 2
  - 각 정점의 노드 수 = 각 정점의 차수

- 유향 그래프
  - 노드 수 = 간선수
  - 각 정점의 노드 수 = 각 정점의 진출 차수

#### 5.2.2 단점

- 유향 그래프의 진입 차수 찾기 위해선 모든 정점 탐색 (진출차수)

## 6. 그래프 탐색

- 그래프 순회 : 비선형구조인 그래프로 표현된 모든 정점을 빠짐없이 탐색하는 것
- Depth First Search
  - 무향그래프 & 1명의 친구에게 전달 & 중복 X &  최대 전달 갯수
- Breadth First Search
  - 무향그래프 & 모든 친구에게 전달 & 가능 늦게 받는 친구

### 6.1. DFS

- 시작 정점의 한 방향으로 깊이 탐색, 마지막 갈림길 정점(간선有)으로 돌아와 다른 방향 깊이 탐색
- 후입선출 구조의 ```스택``` 사용

```python
def DFS_rec(G, v):
    visited[v] = True
    for w in G[v]:
        if not visited[w]:
    # for i in range (1, len(G)):
        # if G[v][i] and not visited[i]:
            DFS(G, w)
```
```python
def DFS_iter(v):
	s = [v]
	visited[v] = True
	while s:
        now = s.pop()
        # 수행
        for w in G[now]:
            if not visited[w]:
        # for i in range (1, len(G)):
            # if G[now][i] and not visited[i]:
                s.append(w)
                visited[w]
```

### 6.2. BFS

- 시작점의 인접정점부터 모두 차례로 방문하고, 방문했던 정점을 시작점으로 하여 반복
- 선입선출형태의 자료구조인 큐를 활용

#### 6.2.1 Queue

- 스택처럼 삽입(enQueue) & 삭제(deQueue)의 위치가 제한적인 구조
- 선입선출형태 (FIFO, First In First Out)
- 용어
  - Front
  - Rear

- 공백 큐 생성 : `front = rear = -1`
- 원소 삽입 : `rear += 1; q[rear]=삽입원소`
- 원소 반환 : `front += 1; 반환원소=q[front]`

```python
def EnQueue(Q, X):
    if Q.isFull(): # rear == len(Q)-1
        pass
    else:
        rear += 1
        Q[rear] = X
def DeQueue(Q):
    if Q.isEmpty(): # front == rear
        pass
    else:
        front += 1
        return Q[front]
```

```python
def bfs(G, v):
    q = deque([v])
    visited[v] = 1
    while q:
        v = q.popleft()
        # 정점에서 수행할 행동
        for w in G[v]:
            if not visited[w]:
                q.append(w)
                visited[w] = 1
```

## 7. 상호배타 집합 (Disjoint - sets)

> 서로소 집합 or 상호배타 집합, 서로간에 교집합이 공집합인 집합
>
> 대표자 (representative)

- 표현
  - 연결 리스트
  - 트리
- 연산
  - Make-Set( x ) : 원소 x를 유일한 원소로하는 집합 생성
  - Find-Set( x ) : x가 포함된 집합의 대표자 리턴
  - Union( x, y) : x, y가 각각 포함된 집합을 합집합

### 7.1. 상호배타 집합의 표현 - 연결리스트

- 특징
  - 같은 집합의 원소들을 하나의 연결리스트로 관리
  - 맨 앞의 원소를 집합의 대표 원소로 삼는다
  - 각 원소는 ```집합의 대표원소를 가리키는 링크```를 갖는다

### 7.2 상호배타 집합의 표현 - 트리

#### 7.2.1 특징

- 상호배타 집합은 연결리스트보다 트리를 주로 활용
- 하나의 상호배타 집합을 하나의 트리로 표현
- 자식 노드가 부모 노드를 가리키며 루트노드가 대표자가 된다
- 트리의 배열을 이용

```python
# p: 부모, x: 정점
def make_set(x):
    p[x] = x
def find_set(x):
    if x == p[x]:
        return x
    else:
        find_set(p[x])
def union(x):
    p[find_set(y)] = p[find_set(x)]
```

#### 7.2.2 문제점

- 대표자를 찾기 위해 재귀표현이 길어질 가능성 존재
- 대표자를 바로 찾을 수 있도록 : ```path compression```

#### 7.2.3 연산의 효율을 높이는 방법

##### 7.2.3.1 Rank를 이용한 Union

- 각 노드는 자신을 root로 하는 subtree의 높이를 Rank라는 이름으로 저장한다
- 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙인다

##### 7.2.3.2Path compression

- Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어 준다

```python
def make_set(x):
    p[x] = x
    rank[x] = 0
def find_set(x):
    if x != p[x]:
        p[x] = find_set(p[x])
    return p[x]
def union(x):
    Link (find_set(x), find_set(y))
def Link (px, py): #각 집합의 부모 px, py
    If rank[px] > rank[py]:
        p[py] = px
    else:
        p[px] = py
        if rank[px] == rank[py]:
            rank[y] += 1
```
