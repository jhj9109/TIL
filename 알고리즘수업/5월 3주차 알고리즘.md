# 5월 3주차 알고리즘

## 응용3. 분할정복 & 백트래킹

분할 정복(Divide and Conquer) > 퀵 병합 정렬

상태 공간 트리 모든 노드 검색 하는 백트래킹

이진 트리 특성, 탐색 삽입 삭제 

### 분할정복

#### 가짜 동전 찾기

- n개 동전
- 1:1 비교 : n//2번 수행 = 평균 n/4 + 1/2 = O(n)

- 2 그룹 비교 :  logn번 수행

### 설계 전략

- Divide: 해결할 문제를 여러개의 작은 부분으로 나눈다
- Conquer: 나눈 작은 문제를 각각 해결한다
- Combine: (필요시) 해결된 해답을 모은다

Top-Down Approach

- 크기 N 문제 > 크기 N/2 부분 문제 > 부분 문제의 해 > 전체 문제의 해 

거듭제곱

- Iterative 알고리즘: O(n)
- 분할 정복 기반 알고리즘: O(logn)

```python
def rec_power(C, n):
    if n == 1:
        return C
    if n % 2 == 0 : # even
        y = rec_power(C, n/2)
        return y * y
    else:
        y = rec_power(C, n/2)
        return y * y * C
```

병합정렬 (Merge Sort)

- 여러개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 분할 정복 알고리즘 활용
  - 자료를 최소 단위 문제까지 나눈 후, 차례대로 정렬
- 시간 복잡도
  - O(nlogn)

- 두 그룹의 가장 작은값부터 비교하여 한 그룹이 끝장날때까지 계속

```python
def merge_sort(lst):
    if len(lst) == 1:
        return lst[0]
    
    # 문제를 나누는 부분
    mid = len(lst) // 2
    left, right = lst[:mid], lst[mid:]
    
    # 나눈 각 문제를 해결
    left = merge_sort(left)
    right = merge_sort(right)
    
    return merge(left, right)

def merge(lst1, lst2):
    res = []
    while len(lst1) and len(lst2):
        if lst1[0] <= lst2[0]:
            res.append(lst1.pop(0))
        else:
            res.append(lst2.pop(0))
    if len(lst1):
        res.extend(lst1)
    else:
        res.extend(lst2)
    return res
```

퀵 정렬

- 주어진 배열을 두개로 분할, 각각 정렬
- pivot 아이템을 중심으로 작은것은 왼편 큰것은 오른편에 위치
- merge가 불필요하다.

```python
def q_sort(arr, l, r):
    if l > r:
        return
    pivot = h_p(arr, l, r)
    q_sort(arr, l, p-1)
    q_sort(arr, p+1, r)
    

def hoare_partition(arr, l, r): #Hoare-Partition 알고리즘, 둘중 1/3배
    pivot < arr[l]
    i, j = l, r
    while i <= j:
        while i<= j and arr[i] <= pivot:
            i += 1
        while i<= j and arr[j] >= pivot:
            j -= 1
        if i < j:
            arr[i], arr[j] = arr[j], arr[i]
    arr[l], arr[j] = arr[j], arr[l]
    return j

def lomuto_partition(arr, l, r): #Lomuto-Partition 알고리즘
    pivot = arr[r]
    i = l - 1
    for j in range(l, r): #i~j구간의 모든 값은 p보다 큰값이 된다.
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    # i: 피봇보다 작은 마지막 값의 위치
    a[i+1], a[r] = a[r], a[i+1]
    return i + 1
```

병뚜껑 속의 숫자 찾기

- 이진 검색
- 자료가 정렬된 상태여야 한다.
- 검색과정
  - 중앙의 원소 선택
  - 목표값과 비교후 새로운 범위에 대한 검색 수행
  - 목표값을 찾을때까지 계속한다.

```python
def b_sch(N, arr, key):
    l, r = 0, N-1
    while l <= r and location = 0:
        mid = (l + r) // 2
        if arr[min] == key:
            return mid
        elif s[mid] > key:
            r = mid - 1
        else:
            l = mid + 1
    return -1
```

## 0515 백트래킹

### 백트래킹

- 여러 옵션 중 한가지를 선택
- 선택이후, 새로운 옵션집합이 생성
- 반복하며, 최종 상태에 도달한다.
  - 올바른 선택시, goal state에 도달

- N-queen에서 놓을 수 있는지 여부 판단  == Prunning 가지치기

- 8Queen : 44억 후보 > 92개의 정답 찾기
- root에서 leaf 노드 하나의 경로 == 해답후보 (candidate solution)

절차

- 상태 공간 트리DFS
- 각 노드 유망 (promising) 점검
- 유망하지 않으면 부모 노드의 다음 스탭으로 진행

순열 백트래킹 구현

```python
def backtrack(result, selected, idx, N):
    if idx == N:
        print(result)
        return
    for i in range(N):
        if not selected[i]:
            selected[i] = 1
            result[idx] = i
            backtrack(result, selected, idx+1, N)
            selected[i] = 0
N = int(input())
backtrack([0]*N, [0]*N, 0, N)
```

powerset중 원소의 합이 10

```python

```

