# DFS

## 반복 탐색

1. 노드 V에서 가능한 경로 W를 스택에 push
2. W중 1개 택하여 Go (기록)
3. 다음 노트 V에서 가능한 경로 W를 스택에 push (스택에 이미 포함된 경로 제외)
4. 자연스럽게 길따라 가다가, 길이 없으면 스택에 있는 지점으로 순간이동하게됨

## 재귀 탐색

1. 노트 V에서 가능한 경로 중 1개 택하여 Go (기록)
2. 길이 없을때까지 GO (기록)
3. 길이 없으면 출발지로 돌아와 반복

###### 어제까지 1~4까지 갈 수 있니 없니?

# 가능한 경로 찾기

1. visited 체크를 하게 되면 중복가능한 경로 탐색 불가 >>> Nob

   ex) 1-2-3 >>> 1-2-4-3

2. visited 체크를 하지 않게 되면 되돌아가게됨 >>> Nob

3. 기록은 하되, 갈림길로 되돌아갈때 기록 삭제 >>> 즉, 갈림길 이후 ~ 최종까지의 경로 삭제

   ex) (1)-3-4-5 경로1 >>> 3,4,5삭제 >>> (1)-2-3-4-5 경로2

   프로세스 (1)에서 2 기억 >>>(1)-3-4-5 수행 >>> 5기록삭제 - 4기록삭제 - 3기록삭제 - 2탐색 

### 재귀

```python
DFS(v, k): #k는 목표로 하는 도착지 노드
    if v == k:
        cnt += 1
    else:
        V[v] = True
        for w in range(1, V+1): #G[v][w] v가 w로가는 간선의 존재 여부
            if G[v][w] == True and V[w] == False:
                DFS(w, k)
        V[v] = False
```

### 재귀 + 최단거리

```python
DFS(v, k, e):
    if v == k:
        if e < min:
            min = e
    else:
        V[v] = True
        for w in range(1, V+1):
            if G[v][w] == True and V[w] == False:
                DFS(w, k, e+1)
        V[n] = False
```

### 재귀 + 최단거리 + 일찍포기

```python
DFS(v, k, e):
    if v == k:
        if e < min:
            min = e
    elif e >= min:
        pass #일찍포기
    else:
        V[v] = True
        for w in range(1, V+1):
            if G[v][w] == True and V[w] == False:
                DFS(w, k, e+1)
        V[n] = False
```

### 재귀 + 최단거리 + 일찍포기 + 헨젤과 그레텔

> 가는 경로에 과자(이동거리) 표시, 경로 탐색중 내가 가진 과자보다 작은 과자 만나면 포기

```python

```



### 반복

```python

```

BFS = 넓이 탐색 = 최단 거리순 탐색 >>> DFS로 최단 거리 탐색해보기

```python
DFS(n,)
```

