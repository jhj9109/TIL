# 알고리즘

> 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
> 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

## 알고리즘 표현법
1. 슈도코드
> 특정 프로그램 언어 문법을 따라 쓰여진 것이 아닌 코드를 흉내내어 작성한 코드
> 대략적인 모델링에 사용
2. 순서도
> 프로그램이나 작업의 진행 흐름을 순서에 따라 나타낸 도표
> 프로그램의 흐름과 과정 파악에 필요

## 알고리즘 성능
1. 정확성
2. 작업량 : 연산 횟수
3. 메모리 사용량
4. 단순석
5. 최적성

### 알고리즘 성능분석
ex) 1~100 합을 구하는 문제
- 방법1. 1+2+...+100 : 99번의 연산 (+:99)
- 방법2. (1+100)*100/2 : 3번의 연산 (+:1,\*:1,/:1)

복잡도 측정
- 실제 걸리는 시간 측정
- 명령문의 개수 (주로 사용)
- 예시) 2n+1
    def calcSum(n):
        sum = 0     #1번
        for i in range(1,n+1): #1번
            sum += i # 1번
        ruturn sum
- 예시) 3
    def calcSum(n):
        return n*(n+1) // 2 #3번

### 빅오 표기법
> 시간 복잡도 함수 중, 가장 큰 영향력의 n에 대한 항으로 표시
> Cofficient는 생략
- 예시 : O(2n+1) = O(2n) = O(n)
- 예시 : O(2n^2+10n+100) = O(n^2)
- 에시 : O(4) = O(1) 

# List1
## 파이썬의 특징
1. 인터프리어 언어로 독립적인 플랫폼
> 미리 컴파일 하지 않고 소스 실행시 컴파일 >>> 느리지만 독립적인 플랫폼 가능
2. 객체지향, 함수형 언어
3. IOT의 라즈베리파이, 빅데이터 자료분석에서 파이썬의 관심이 높아짐
> 실행속도가 아닌 개발 시간 단축에 관심 집중

### 변수
1. 파이썬에서는 모든 자료는 객체
2. 변수의 선언은 따로 없다

### 자료형
1. tuple : 수의 나열은 tuple로 인식, packing & unpacking
2. list
3. dictionary
4. set

## 배열과 List
> 변수를 하나의 이름으로 열거하여 사용하는 자료구조
> 배열 : 같은 타입의 변수 데이터만 저장가능, 크기 변경 불가능
> LIST : 다양한 데이터 저장 가능, 크기 가변적 변경 가능
### List 사용법
1. 선언 방법 불필요, 처음 값을 할당 시 생성
2. 공백 리스트 생성시 빈 리스트 객체 형성하거나, list생성자를 이용한다.
    num = []; num2 = list()

### Sequence 자료형
> 순서가 존재, 인덱싱과 슬라이싱 연산 모두 적용가능
>
> 1. 인덱싱 :  하나의 요소를 인덱스 연산자를 통하여 참조하는 것 `data[인덱스]`
2. 슬라이싱 : 원하는 범위를 선택하는 연산 `data[시작:끝]`

### 함수와 연산
1. len() : 원소 개수
2. \+  : 시퀀스 연결 ex) [1,2]+[3,4] = [1,2,3,4]
3. \*  : 반복 ex) [1,2]*2 = [1,2,1,2]
4. in : 포함 ex) 2 in [1,2,3] = True
5. not in : 불포함 ex) 2 not in [1,2,3] = False
6. min() : 원소중 최소값 ex) min([1,2,3]) = 1
7. max() : 원소중 최대값 ex) max([1,2,3]) = 3
8. sorted() : 정렬된 리스트 반환 ex) sorted([3,1,2]) = [1,2,3]
9. append() : 리스트 끝에 추가 ex) a=[1,2], a.append(3) = [1,2,3]
10. insert() : 인덱스에 삽입 ex)a=[1,2], a.insert(1,4) = [1,4,2]
11. pop() : 인덱스에 삭제 ex)a=[1,2,3], a.pop(2) = [1,3]
    12. remove() : 첫번째 요소만 삭제 ex)a=[3,4,5], a.remove(4) = [3,5]
13. count() : 값의 갯수 ex)a=[1,1,1,2,3], a.count(1) = 3

### 리스트 함축(List Comprehension)
> 수학에서 집합을 정의하는 표현식과 유사
- mylist = [2,3,4,5,6]
- newlist = [i for i in mylist if i%2==0] = [2,4,6]

# 완전 탐색 Exhaustive  Search
> 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
> Brute-force 혹은 Generate-and-Test 기법이라고도 불림
1. 모든 경우의 수를 테스트한 후, 최종 해법을 도출
2. 경우의 수가 상대적으로 작을 때 유용
3. 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
4. 완전 탐색으로 해답 도출 후, 성능 개선을 위한 다른 알고리즘 사용하는 것이 바람직함

## Baby-gin Game by Exhaustive Search
> 0~9사이의 숫자중 임의의 카드 6장중 3연속 run, 3동일 triplete
> 6장의 카드 모두 run, triplete로만 구성된 경우 Baby-gin
### 완전탐색
    1. 6개의 숫자로 만들 수 있는 모든 순열 생성
    2. 앞 뒤 각 3자리로 나눠 run과 triplete 여부를 테스트하여 판단

### 순열(Permutation)
> 서로 다른 것들 중 몇 개를 뽑아서 한줄로 나열하는 것
> 서로 다른 n개중 r개 택 : nPr = n * (n-1) * ... * (n-r+1)
> nPn = n!(Factorial) = n*(n-1)*...*1

### {1,2,3}을 포함하는 모든 순열 생성하는 함수
```python
for n1 in range(1,4):
    for n2 in range(1,4):
        if n2!=n1:
            for n3 in range(1,4):
                if n3 != n1 and n3 != n2 :
                    print(n1,n2,n3)

```

# 탐욕 알고리즘 Greedy Algorithm
> 최적 해를 구하는데 사용되는 근시안적인 방법
1. 여러 경우 중 그 순간 최적이라고 생각되는 것을 선택해 나가는 방식으로 해답에 도달하는것
2. 지역적인 최적 선택이 최종적인 최적이라는 보장은 없음
3. 일반적인 접근이 Greedy 접근

## 수행과정
1. 해 선택
- 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가
2. 실행 가능성 검사
- 새로운 부분 해 집합이 실행 가능한지를 확인
- 곧, 문제의 제약 조건을 위반하지 않는지를 검사함
3. 해 검사
- 새로운 부분 해 집합의 문제의 해가 되는지를 확인
- 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작

### 거스름돈 줄이기
1. 해 선택 : 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가
2. 실행 가능성 검사 : if 거스름돈 > 액수 : last 거스름돈 빼고, 해 선택에 작은 단위 추가
3. 해 검사 : if 거스름돈 < 액수 : 해 선택에 작은 단위 추가

### Baby-gin by Greedy Algorithm
1. 6개의 숫자는 6자리의 정수 값으로 입력됨
2. counts 리스트의 각 원소를 체크하여 run과 triplete 및 Baby-gin 여부 판단
    1. Greedy Algorithm 적용
    2. counts 리스트에서 run과 triplete 가능한 것을 조사
    3. 조사에 사용된 데이터 삭제
    4. 남은 데이터중 run과 triplete 가능한지 조사
```python
num_str = input()
num_int = [int(x) for x in num_str]
cnt = [0] * 12# run 탐색시 index 오류 피하기 위함
for n in num_int:
    cnt[n] += 1

tri, run = 0, 0
for idx, val in enumerate(cnt):
    if val >=3 :
        cnt[idx] -= 3
        tri += 1
    if cnt[idx] >= 1 and cnt[idx+1] >= 1 and cnt[idx+2] >= 1:
        cnt[idx]-=1
        cnt[idx+1]-=1
        cnt[idx+2]-=1
        run += 1
if run + tri == 2 :
    print("Baby run")       
```
실패 예시
1. 입력 받은 숫자 정렬
2. 앞뒤 3자리씩 끊어서 조사
{1,2,3,1,2,3} >>> {1,1,2,2,3,3} 으로 확인 실패

# sort
> 정렬이란 특정 기준에 의해 오름차순(ascdending) 혹은 내림차순(descending) 재배열 하는것
> 키 : 자료를 정렬하는 기준이 되는 특정 값 ex) 서류번호, 카드번호
- 종류 : 버블, 카운팅, 선택, 퀵, 삽입, 병합

## Bubble Sort
> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
> **시간복잡도 : O(n^2 )**

{20, 0, 30 , 5, 10 } 정렬

1. 20 과 0 비교 : 0, 20 (교환)
2. 20 과 30 비교 : 20, 30 
3. 30 과 5 비교 : 5, 30 (교환)
4. 30과 10 비교 : 10, 30 (교환)
5. ∴ 가장 큰 값인 30은 맨 뒤에 정렬 되었다.
- **바깥 반복문에 내부 반복문의 횟수가 변화한다.**
    ```python
    numbers =list(map(int, input().split(' ')))
    for i in range(len(numbers)-1):
        for k in range(len(numbers)-1-i):
            if numbers[k] > numbers[k+1]:
                numbers[k], numbers[k+1] = numbers[k+1], numbers[k]

    ```

## Counting Sort
> 각 항목이 몇개씩 있는지 세는 작업을 통해 선형 시간에 정렬하는 효율적인 알고리즘
> 정수나 정수로 표현가능한 자료에 대해서만 적용가능
> ∵각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 리스트 사용
> 카운트들을 위한 충분한 공간을 할당하기 위해 집합내의 가장 큰 정수를 알아야함
> **시간복잡도 = O(n+k)**, n=리스트갯수, k:최대정수값

{0,4,1,3,1,2,4,1} 정렬

1. Data에서 각 항목 카운팅, 정수 항목들로 직접 인덱스 되는 카운트 리스트 COUNTS 저장
   DATA =   0,4,1,3,1,2,4,1
   COUNTS = 1,3,1,1,2
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS 원소 조정
   **COUNTS = 1,4,5,6,8** 
   
   ```python
   for i in range(max(numbers)):
    cnt[i+1] += cnt[i]
   ```
3. COUNTS[1]를 4->3 : 1 감소시키고 [3]에 삽입
4. COUNTS[4]를 8->7 : 1 감소시키고 [7]에 삽입
5. COUNTS[2]를 5->4 : 1 감소시키고 [4]에 삽입
6. 반복하여 정렬을 완성한다

    ```python
    numbers =list(map(int, input().split(' ')))
    sort_num = [0] * len(numbers)
    cnt = [0]*(max(numbers)+1)
    for number in numbers:
        cnt[number] += 1
    for i in range(max(numbers)):
        cnt[i+1] += cnt[i]
    for i in range(len(numbers)):
        cnt[numbers[i]] -= 1
        sort_num[cnt[numbers[i]]] = numbers[i]
    print(sort_num)

    ```

## 기타 정렬들의 특징

| 알고리즘 | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고                                  |
| :------: | :-----------: | :-----------: | :-----------: | ------------------------------------- |
|   버블   |    O(n^2)     |    O(n^2)     |  비교와 교환  | 코딩이 가장 손쉬움                    |
|  카운팅  |    O(n+k)     |    O(n+k)     |  비교환 방식  | n이 비교적 작을때만 가능              |
|   선택   |    O(n^2)     |    O(n^2)     |  비교와 교환  | 교환의 횟수가 버블, 삽입정렬보다 작음 |
|    퀵    |   O(nlogn)    |    O(n^2)     |   분할 정복   | 최악의 경우외, 평균적으로 가장 빠름   |
|   삽입   |    O(n^2)     |    O(n^2)     |  비교와 교환  | n의 개수가 잘을 때 효과적             |
|   병합   |   O(nlogn)    |   O(nlogn)    |   분할 정복   | 연결 리스트의 경우 가장 효율적인 방식 |

# LIST2

## Ⅰ. 2차원 List

> 세로(행), 가로(열)

### (1) 선언

```python
list1 = [i for i in range(2,10) if not(i % 2)] # [2,4,6,8]
list2 = [ [1,2,3] ] * 3 # [ [1,2,3], [1,2,3], [1,2,3] ]
list3 = [ [1,2,3] for _ in range(3)]
list4 = [ [i,j] for i in range(3) for j in range(2)]
# [[0,0],[0,1],[1,0],[1,1],[2,0],[2,1]]
```

**list4 = [ [i,j] for i in range(3) for j in range(2)]**

**# [[0,0],[0,1],[1,0],[1,1],[2,0],[2,1]] **

### (2) 입력

```python
list1 = [0]*n
for i in range(n):
    list1[i] = list(map(int, input().split()))
list2 = []
for i in range(n):
    list2.append(list(map(int, input().split())))
    
list3 = [list(map(int, input().split())) for _ in range(n)]
```

### (3) 특정 값의 인덱스 찾기

```python
new_list = [(i,j) for i in range(n) for j range(m) if mylist[i][j]==특정 값 ]
```

**new_list = [(i,j) for i in range(n) for j range(m) if mylist[i][j]==특정 값 ]**

### (4) 순회

- 행순회 / 열순회

  ```python
  for i in range(len(list)): # i, j 내부/외부 for문 바꿔주면 열순회
      for j in range(len(list[i])):
          list[i][j] # 필요한 연산 수행
  ```

- 지그재그 순회

  ```python
  for i in range(len(list)):
      for j in range(len(list[i])):
          list[i][ j + ( len(list[i] - 1  -   2 * j ) * (i % 2) ] #필요한 연산 수행
  ```

### (5) 델타를 이용한 탐색

> 상하좌우에 원소들이 존재하지 않을 경우, Index체크 or Index범위제한이 필요

```python
dx = [0,0,-1,1]
dy = [-1,1,0,0]

for y in range(len(list)): # i, j 내부/외부 for문 바꿔주면 열순회
    for x in range(len(list[i])):
        for i in range(4):
            testX = x + dx[i]
            testY = y + dy[i]
            print(list[testY][testX])
```

### (6) 전치 행렬

> 행과 열의 값이 반대인 행렬을 의미

```python
for y in range(n):
    for x in range(n):
        if y < x:
            list1[y][x], list1[x][y] = list1[x][y], list1[y][x]
```

- zip(iterable*) : 전치행렬

  ```python
  list1 = [[1,2,3],[4,5,6],[7,8,9]]
  list2 = list(zip(*list1)) # [(1,4,7),(2,5,8),(3,6,9)]
  ```

## Ⅱ. 부분 집합

### (1) 부분 집합 알고리즘

```python
bit [0,0,0,0]
for i range(2):
    bit[0] = i
    for j range(2):
        bit[1] = j
        for k range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print(bit)
```

### (2) 비트 연산자

> 0과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자

- `&` : 비트 단위로 AND 연산을 함
- `|` : 비트 단위로 OR 연산을 함
- `<<` : 피연산자의 비트 열을 왼쪽으로 이동시킴
- `>>` : 피연산자의 비트 열을 오른쪽으로 이동시킴

`1<<n:2^n` : 원소가 n개 부분 집합의 수

`i&(1<<j):1` : i에서 j번째 비트가 1인지 아닌지를 리턴함

```python
list1 = [1,2,3,4,5,6]
n = len(list1)

for i in range(1<<n): #1<<n : 부분 집합의 개수
    for j in range(n):
        if i&(1<<j): #i의 j번째 비트가 1이면 j번째 원소 출력
            print(list1[j], end=',')
    print('')
```

## Ⅲ. 검색

> 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
>
> 원하는 항목 : 목적하는 탐색키를 가진 항목
>
> 탐색키 : 자료를 구별하여 인식할 수 있는 키

종류 : 순차 검색, 이진 검색, 인덱싱

### (1) 순차검색

> List, 연결List 순차구조로 구현된 자료구조에서 유용함
>
> 검색 대상이 많은 경우 수행시간의 증가로 비효율적임

- 정렬되지 않은 자료 검색

1. 첫번째 원소부터 순서대로 검색대상과 키 값이 같은 원소를 비교하여 찾음
2. 찾으면 그 원소의 인덱스를 반환
3. 찾지못하면 검색 실패
4. 평균 비교 횟수 : (n+1)/2 , 시간복잡도 : O(n)

```python
i = 0
while i < n and a[i]!=key:
    i = i + 1
if i < n :
    return i
else:
    return -1
```

- 정렬된 자료의 검색

1. 오름차순 정렬된 자료, 첫번째 원소부터 순차 검색
2. 원소의 키값이 찾고자하는 키값보다 크면 검색 종료
3. 평균 비교 횟수 : (n+1)/4, 시간복잡도 : O(n)

```python
i = 0
while i < n and a[i]<key:
    i = i + 1
if i < n and a[i] == key :
    return i
else:
    return -1
```

### (2) 이진 검색

> 중간 항목과 비교 후, 다음 탐색 위치를 결정하고 검색하는 방법
>
> 자료가 정렬된 상태여야 함
>
> 시간 복잡도 : O(logN)

```python
def binarySearch(list1, key):
    start = 0
    end = len(list1) - 1
    while start <= end:
        middle = start + (end - start) // 2
        if key == list1[middle]: #검색 성공
            return True
        elif key < list1[middle]:
            end = middle - 1
        else:
            start = middle + 1
    return False #검색 실패
```

```python
def binarySearch2(list1, low, high, key):
    if low > high: #검색 실채
        return False
    else:
        middle = (low + high) // 2
        if key == list1[middle]: #검색 성공
            return True
        elif key < list1[middle]:
            return binarySearch2(a, low, middle-1, key)
        elif list1[middle] < key:
            return binarySearch2(a, middle+1, high, key)
```

### (3) 인덱스

- DB에서 유래, 테이블에 대한 동작 속도를 높임
- Look up table등의 용어로 사용
- 인덱스를 저장하는 공간은 테이블보다 적음
- 데이터 정렬에 원본 List 외에, List 인덱스를 추가하여 사용



## Ⅳ. 정렬

### (1) 셀렉션 알고리즘

> 저장되어 있는 자료에서 K번째로 큰 원소를 찾는 방법 (최대,최소,중간값)

셀렉션 선택 과정

- 정렬 알고리즘을 이용하여 자료를 정렬
- 원하는 순서에 있는 원소 가져오기